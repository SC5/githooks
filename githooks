#!/usr/bin/env ruby
require 'rubygems'
require 'grit'
require 'optparse'

options = {}

class GitHooks
  def initialize(opts)
    @options = opts
    @options[:repodir] ||= path = %x[git rev-parse --show-toplevel 2>/dev/null].chomp
    @options[:action] ||= :default
    @options[:quiet] ||= false
    @options[:status] = true
    @options[:githooksdir] ||= File.expand_path(File.join(File.dirname(__FILE__),"hooks"))
    @options[:chains] = [ 'applypatch-msg', 'commit-msg', 'post-applypatch', 'post-checkout', 'post-commit',
                          'post-merge', 'post-receive', 'post-rewrite', 'post-update', 'pre-applypatch',
                          'pre-auto-gc', 'pre-commit', 'pre-rebase', 'pre-receive', 'prepare-commit-msg',
                          'update']
    @options[:hooks] = []
    begin
      @repo = Grit::Repo.new(@options[:repodir])
      listAll(true)
    rescue Exception => e
      @options[:status] = false
    end
  end

  def getItems
    items = @options[:chains]
    items = @options[:extra] if @options[:extra] != :default and @options[:chains].include?@options[:extra]
    return items
  end

  def listAll(quiet = false )
    items = getItems
    puts "Available git hooks" if quiet == false
    storage = Hash.new
    items.each { |item|
      tmp = Array.new
      pattern = "#{@options[:githooksdir]}/#{item}/*"
      Dir.glob(pattern).each { |entry|
        tmp << File::basename(entry)
      }
      storage[item] = tmp
      puts "#{item}: #{tmp.join(", ")}" if tmp.length>0  and quiet == false
    }
    @options[:hooks] = storage
    return 0
  end

  def listInstalled(quiet = false)
    items = getItems
    puts "Installed git hooks" if quiet == false
    items.each { |item|
      tmp = []
      pattern = "#{@repo.path}/hooks/#{item}.*"
      Dir.glob(pattern).each { |entry|
        begin
          entry.slice! "#{item}."
          tmp << File::basename(entry)
        end if ! entry.include?(".sample")
      }
      puts "#{item}: #{tmp.join(", ")}" if tmp.length>0 and quiet == false
    }
    return 0
  end

  def isRepoValidForGitHookChains(chain = nil)
    items = getItems
    items = chain if chain != nil
    ret = 0
    items.each { |entry|
        source = "#{@repo.path}/hooks/#{entry}"
        target = "#{@options[:githooksdir]}/hookchain"
        if File::exists?(source) then
          if File::symlink?(source) == false or (File::readlink(source) == target ) == false then
            ret = 1
          end
        end
    }
    return ret
  end

  def getChainFromHooks(hook)
    @options[:hooks].keys.each { |key|
      if @options[:hooks][key]  != nil then
        #puts "-----------------"
        #p key
        #p @options[:hooks][key]
        #p hook
        #p @options[:hooks][key].include?(hook)
        #puts "-----------------"
      end
      return key if @options[:hooks][key] != nil and @options[:hooks][key].include?(hook)
    }
    return nil
  end

  def installHook
    ret = 1
    hook = @options[:extra]
    chain = getChainFromHooks(hook)
    if chain != nil and installHookChain(chain) == 0 then
      target = "#{@repo.path}/hooks/#{chain}.#{hook}"
      source = "#{@options[:githooksdir]}/#{chain}/#{hook}"
      begin
        if File::exists?(source) and File::symlink?(target) and File::readlink(target) == source then ## readlink should be enought but lets keep it like this
          ret = 0
        elsif File::symlink(source, target) then
          ret = 0
        end
      rescue Exception => e
      end
    end
    return ret
  end

  def installHookChain(chain)
    ret = 1
    if isRepoValidForGitHookChains(chain) then
      target = "#{@repo.path}/hooks/#{chain}"
      source = "#{@options[:githooksdir]}/hookchain"
      begin
        if File::exists?(target) and File::symlink?(target) and File::readlink(target) == source then
          ret = 0
        elsif File::symlink(source, target) then
          ret = 0
        end
      end
    end
    return 0
  end

  def deleteHook
  end

  def run
    ret = 0
    if @options[:status] == true then
      case @options[:action]
      when :listAll
        ret = listAll
      when :listInstalled
        ret = listInstalled
      when :deleteHook
        ret = deleteHook
      when :installHook
        ret = installHook
      when :default
        puts @options[:opts].help
      else
        puts "Unknown action"
        ret = 1
      end
    else
      ret = 2
    end
    return ret
  end
end

options = {}

OptionParser.new do |opts|
  opts.banner = "Usage: githooks [options]"

  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end

  opts.on("-q", "--quiet", "Run quietly") do
    options[:quiet] = true
  end

  opts.on("-a", "--available-hooks [CHAIN]","Lists all available hooks") do |ext|
    options[:action] = :listAll
    options[:extra] = ext
    options[:extra] ||= :default
  end

  opts.on("-l", "--list-installed-hooks [CHAIN]","Lists installed hooks on given repository") do |ext|
    options[:action] = :listInstalled
    options[:extra] = ext
    options[:extra] ||= :default
  end

  opts.on("-d", "--delete-hook=hookname]","Lists installed hooks on given repository") do |ext|
    options[:action] = :deleterHook
    options[:extra] = ext
    options[:extra] ||= :default
  end

  opts.on("-i", "--install-hook=hookname","Install given hook to current repository") do |hook|
    options[:action] = :installHook
    options[:extra] = hook
  end

  opts.on("-r", "--repository=directory","Use given clone instead of current repository") do |dir|
    options[:repodir] = File::expand_path(dir)
  end

  options[:opts] = opts
end.parse!

if __FILE__ == $0 then
  options[:invoked] = :executable
  hooks = GitHooks.new(options)
  exit hooks.run
else
  options[:invoked] = :module
end

